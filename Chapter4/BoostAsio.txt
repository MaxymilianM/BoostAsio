
# Boost.Thread with Boost.Asio
The Boost libraries also have the Boost.Thread library that is used to execute tasks concurrently,
but the Boost.Thread library is used to access internal resources,
such as the CPU core resource, while the Boost.Asio library is used to access external resources,
such as network connections, because the data is sent and received by a network card.

# Boost I/O service
The core object of the Boost::Asio namespace is io_service.
The I/O service is a channel that is used to access operating system resources
and establish communication between our program and the operating system that performs I/O requests.
There is also an I/O object that has the role of submitting I/O requests.
For instance, the tcp::socket object will provide a socket programming request from our program to the operating system.


# Using and blocking the run() function
One of the most frequently used functions in the I/O service object is the run() function.
It is used to run the io_service object's event processing loop.
It will block the next statement program until all the work in the io_service object is completed
and there are no more handlers to be dispatched.
If we stop the io_service object, it will no longer block the program.

# Event
In programming, event is an action or occurrence detected by a program,
which will be handled by the program using the event handler object.
The io_service object has one or more instances where events are handled, which is event processing loop.

# io_service:: run(), poll(), post(), dispatch()
There are two functions that we can use to get the io_service object working for us: the run() and poll() member functions.
The run() function blocks the program because it has to wait for the work that we assign to it,
while the poll() function does not block the program.
When we need to give some work to the io_service object,
we simply use the poll() or run() functions, depending on what we need,
and then we call the post() or dispatch() functions as needed.
The post() function is used to command the io_service object in order to run the given handler,
but without permitting the handler is called by the io_service object from inside this function.
While the dispatch() function is used to call the handler in the thread
in which the run() or poll() functions are currently being invoked.
The fundamental difference between the dispatch() and the post() functions is that
the dispatch() function completes the work right away whenever it can,
while the post() function always queues the work.

#io_service:: work
Class to inform the io_service when it has work to do. Using run() or poll().
The work class is used to inform the io_service when work starts and finishes.
This ensures that the io_service object's run() function will not exit while work is underway,
and that it does exit when there is no unfinished work remaining.
After version 1.84.0 work Deprecated: (Use executor_work_guard).

#io_service:: strand
Class that we use to wrap io_service object.
So after every strand.post() call from different threads we will be ordered.

#io_service:: stop()
If it is system failure - we have to invoke the stop() function in the io_service class
to ensure the work object has been destroyed in order for the program to be able to exit.

#deadline_timer:: async_wait(), expires_from_now()
The deadline_timer is a class that provides the ability to block or asynchronous wait
for a timer until it expires, known as the deadline timer.
A deadline timer indicates one of two states: expired or not expired.
Before the program calls the binded function, it has to wait for n seconds
because of usage expires_from_now() function from the timer object.
The async_wait() function will wait until the timer has expired.
In the binded function std::placeholders::_1 will be replaced
with the first argument given from async_wait(), with type boost::system::error_code.

#ip::tcp::socket 
The ::socket class represents an active socket.
Basically, there are two types of sockets (Berkeley Sockets API):
- Active socket - a socket intended to be used to send and receive data to and from a remote application
  or to initiate a connection establishment process with it.
- Passive socket - is the one used to passively wait for incoming connection requests from remote applications.
  Passive sockets don't take part in user data transmission.

#ip::tcp:: resolver, ::query, ::iterator, ::endpoint
::resolver is used to get the address of the remote host that we want to connect with.
With the ::query class, we pass the Internet address and port as a parameter.
The ::query  class is used to describe the ::query that can be passed to a ::resolver.
By using the ::iterator class, we will define iterators from the results returned by a ::resolver.
After the ::iterator is successfully created, we give it to the ::endpoint type variable. 
The ::endpoint will store the list of ip addresses that are generated by the ::resolver.
Then, the socket::connect() member function will connect the socket to the ::endpoint.
To release the connection, we have to disable the sending and receiving data process on the socket first
by using the shutdown() member function. Invoke the close() member function to close the socket after.

#::acceptor
The ::acceptor class represents a passive socket.
Passive socket - is the one used to passively wait for incoming connection requests from remote applications.
Passive sockets are used only in server applications or hybrid applications that may play both roles of the client and server.
Passive sockets are defined only for the TCP protocol.
The ::acceptor object is used for accepting new socket connections by using acceptor::async_accept() function.
The program calls the acceptor::open() function to open the acceptor socket by using the protocol that is retrieved from the endpoint variable.
Then, by using the acceptor::set_option() function, we set an option on the acceptor to not reuse the address.
The acceptor is also bound to the endpoint using the acceptor::bind() function.
After that, we invoke the acceptor::listen() function to put the acceptor into the state where it will listen for new connections.
Finally, the acceptor will accept new connections by using the acceptor::async_accept() function, which will start an asynchronous accept.

#::acceptor::bind()
Before an active socket can communicate with a remote application or a passive socket can accept incoming connection requests,
they must be associated with a particular local IP address (or multiple addresses) and a protocol port number, that is, an endpoint.
The process of associating a socket with a particular endpoint is called binding.
When a socket is bound to an endpoint, all network packets coming into the host
from the network with that endpoint as their target address will be redirected to that particular socket by the operating system.

#::acceptor::listen()
The ::listen() listen for incoming connection requests.
This call switches the acceptor socket into the state in which it listens for incoming connection requests.
The argument (::max_connections) that the listen() method accepts as an argument specifies the size of the queue
maintained by the operating system to which it puts connection requests arriving from the clients.
Before ::listen() call all client's connection requests are rejected by the operating system.
After acceptor socket  switched into listening mode, the operating system allocates a queue for pending connection requests
associated with this acceptor socket and starts accepting connection request addressed to it.
The requests stay in the queue and are waiting for the server application to de-queue and process them. 
When the queue becomes full, the new connection requests are rejected by the operating system.

#::resolver::query()
An object of the resolver::query class representing a DNS name resolution query.

#::basic_stream_socket 
Provides stream-oriented socket functionality (write and read the socket).

#::enable_shared_from_this
Allows an object t that is currently managed by a std::shared_ptr named pt to safely generate
additional std::shared_ptr instances pt1, pt2, ... that all share ownership of t with pt.
class Good : public std::enable_shared_from_this<Good>{...};


#::asio::async_write()
Start an asynchronous operation to write all of the supplied data to a stream.

#::socket::async_read_some()
This function is used to asynchronously read data from the stream socket. The function call always returns immediately.

# Simulate TCP client
We can simulate TCP client by using telnet command: telnet IP_address port
> telnet 127.0.0.1 4444
