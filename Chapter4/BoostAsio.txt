
# Boost.Thread with Boost.Asio
The Boost libraries also have the Boost.Thread library that is used to execute tasks concurrently,
but the Boost.Thread library is used to access internal resources,
such as the CPU core resource, while the Boost.Asio library is used to access external resources,
such as network connections, because the data is sent and received by a network card.

# Boost I/O service
The core object of the Boost::Asio namespace is io_service.
The I/O service is a channel that is used to access operating system resources
and establish communication between our program and the operating system that performs I/O requests.
There is also an I/O object that has the role of submitting I/O requests.
For instance, the tcp::socket object will provide a socket programming request from our program to the operating system.


# Using and blocking the run() function
One of the most frequently used functions in the I/O service object is the run() function.
It is used to run the io_service object's event processing loop.
It will block the next statement program until all the work in the io_service object is completed
and there are no more handlers to be dispatched.
If we stop the io_service object, it will no longer block the program.

# Event
In programming, event is an action or occurrence detected by a program,
which will be handled by the program using the event handler object.
The io_service object has one or more instances where events are handled, which is event processing loop.

# io_service:: run(), poll(), post(), dispatch()
There are two functions that we can use to get the io_service object working for us: the run() and poll() member functions.
The run() function blocks the program because it has to wait for the work that we assign to it,
while the poll() function does not block the program.
When we need to give some work to the io_service object,
we simply use the poll() or run() functions, depending on what we need,
and then we call the post() or dispatch() functions as needed.
The post() function is used to command the io_service object in order to run the given handler,
but without permitting the handler is called by the io_service object from inside this function.
While the dispatch() function is used to call the handler in the thread
in which the run()or poll() functions are currently being invoked.
The fundamental difference between the dispatch() and the post() functions is that
the dispatch() function completes the work right away whenever it can,
while the post() function always queues the work.

#io_service:: strand
Class that we use to wrap io_service object.
So after every strand.post() call from different threads we will be ordered.

#io_service:: stop()
If it is system failure - we have to invoke the stop() function in the io_service class
to ensure the work object has been destroyed in order for the program to be able to exit.

#deadline_timer:: async_wait(), expires_from_now()
The deadline_timer is a class that provides the ability to block or asynchronous wait
for a timer until it expires, known as the deadline timer.
A deadline timer indicates one of two states: expired or not expired.
Before the program calls the binded function, it has to wait for n seconds
because of usage expires_from_now() function from the timer object.
The async_wait() function will wait until the timer has expired.
In the binded function std::placeholders::_1 will be replaced
with the first argument given from async_wait(), with type boost::system::error_code.
